// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © henry_oliver
// Top Dog Trading Wave Counting - Based on Barry Burns methodology

//@version=6
indicator(title = "MAs & Waves", shorttitle = "MA&W", overlay = true, max_labels_count = 500)

// === CONSTANTS ===
// Nord Theme Color
const color NORD0  = #2E3440
const color NORD1  = #3B4252
const color NORD2  = #434C5E
const color NORD3  = #4C566A
const color NORD4  = #D8DEE9
const color NORD5  = #E5E9F0
const color NORD6  = #ECEFF4
const color NORD7  = #8FBCBB
const color NORD8  = #88C0D0
const color NORD9  = #81A1C1
const color NORD10 = #5E81AC
const color NORD11 = #BF616A
const color NORD12 = #D08770
const color NORD13 = #EBCB8B
const color NORD14 = #A3BE8C
const color NORD15 = #B48EAD

// Calculation Constants
const string TREND_UP     = "up"
const string TREND_DOWN   = "down"
const string TREND_FLAT   = "flat"
const string TREND_NONE   = "none"

const float RADIANS_TO_DEGREES = 180 / math.pi

// Cycle letters
const array<string> CYCLE_LETTERS = array.from("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z")

// === INPUTS ===
src = input.source(defval = close, title = "Source")

// EMA
emaVisible = input.bool(defval = true, title = "Visible", group = "EMA")
emaLength = input.int(defval = 15, title = "Length", minval = 1, group = "EMA")
emaOffset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "EMA")
emaColor = input.color(defval = NORD3, title = "Color", group = "EMA")
emaWidth = input.int(defval = 2, title = "Line Width", minval = 1, maxval = 10, group = "EMA")

// SMA 1 (50 SMA - THE TREND INDICATOR)
sma1Visible = input.bool(defval = true, title = "Visible", group = "SMA 1")
sma1Length = input.int(defval = 50, title = "Length", minval = 1, group = "SMA 1")
sma1Offset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "SMA 1")
sma1TrendLookback = input.int(defval = 5, title = "Trend Lookback (Bars)", minval = 1, maxval = 20,
     tooltip = "Number of bars to look back to determine slope angle", group = "SMA 1")
sma1FlatThreshold = input.float(defval = 0.0001, title = "Flat Threshold (Degrees)", minval = 0.0001, maxval = 5.0, step = 0.0001,
     tooltip = "Angle threshold in degrees - slopes between -threshold and +threshold are considered flat", group = "SMA 1")
sma1ColorUp = input.color(defval = color.new(color = NORD8, transp = 60), title = "Color (Up)", group = "SMA 1")
sma1ColorNeutral = input.color(defval = NORD2, title = "Color (Neutral)", group = "SMA 1")
sma1ColorDown = input.color(defval = color.new(color = NORD11, transp = 60), title = "Color (Down)", group = "SMA 1")
sma1Width = input.int(defval = 3, title = "Line Width", minval = 1, maxval = 10, group = "SMA 1")

// SMA 2 & 3
sma2Visible = input.bool(defval = true, title = "Visible", group = "SMA 2")
sma2Length = input.int(defval = 100, title = "Length", minval = 1, group = "SMA 2")
sma2Offset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "SMA 2")
sma2Color = input.color(defval = NORD1, title = "Color", group = "SMA 2")
sma2Width = input.int(defval = 4, title = "Line Width", minval = 1, maxval = 10, group = "SMA 2")

sma3Visible = input.bool(defval = true, title = "Visible", group = "SMA 3")
sma3Length = input.int(defval = 200, title = "Length", minval = 1, group = "SMA 3")
sma3Offset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "SMA 3")
sma3Color = input.color(defval = NORD1, title = "Color", group = "SMA 3")
sma3Width = input.int(defval = 5, title = "Line Width", minval = 1, maxval = 10, group = "SMA 3")

// Wave Counting
showWaves = input.bool(defval = true, title = "Show Wave Numbers", group = "Wave Counting")
showCycles = input.bool(defval = true, title = "Show Cycle Letters", group = "Wave Counting")
periodK = input.int(defval = 5, title = "%K Length", minval = 1, group = "Wave Counting")
smoothK = input.int(defval = 2, title = "%K Smoothing", minval = 1, group = "Wave Counting")
periodD = input.int(defval = 3, title = "%D Smoothing", minval = 1, group = "Wave Counting")
upperMidLevel = input.int(defval = 55, title = "Upper Mid Level", minval = 50, maxval = 100,
     tooltip = "D must return to this level to confirm cycle high", group = "Wave Counting")
lowerMidLevel = input.int(defval = 45, title = "Lower Mid Level", minval = 0, maxval = 50,
     tooltip = "D must return to this level to confirm cycle low", group = "Wave Counting")
waveColor = input.color(defval = NORD3, title = "Wave Label Color", group = "Wave Counting")
waveLabelSize = input.string(defval = "normal", title = "Wave Label Size",
     options = ["auto", "tiny", "small", "normal", "large", "huge"], group = "Wave Counting")
cycleColor = input.color(defval = NORD2, title = "Cycle Label Color", group = "Wave Counting")
cycleLabelSize = input.string(defval = "small", title = "Cycle Label Size",
     options = ["auto", "tiny", "small", "normal", "large", "huge"], group = "Wave Counting")
failedWaveColor = input.color(defval = NORD11, title = "Failed Wave Color", group = "Wave Counting")

// Map wave label size string to size constant
waveLabelSizeConst = switch waveLabelSize
    "auto"   => size.auto
    "tiny"   => size.tiny
    "small"  => size.small
    "normal" => size.normal
    "large"  => size.large
    "huge"   => size.huge
    => size.normal  // fallback

// Map cycle label size string to size constant
cycleLabelSizeConst = switch cycleLabelSize
    "auto"   => size.auto
    "tiny"   => size.tiny
    "small"  => size.small
    "normal" => size.normal
    "large"  => size.large
    "huge"   => size.huge
    => size.small  // fallback



type WaveCounter
    int waveNumber
    string currentTrend
    float wave1Value
    float wave3Value
    float wave5Value
    float wave7Value
    int wave1Bar
    int wave3Bar
    int wave5Bar
    int wave7Bar
    int cycleLetterIndex
    array<float> retraceHighs
    array<int> retraceHighBars
    array<float> retraceLows
    array<int> retraceLowBars

method reset(WaveCounter this, string newTrend) =>
    this.waveNumber := 0
    this.currentTrend := newTrend
    this.wave1Value := na
    this.wave3Value := na
    this.wave5Value := na
    this.wave7Value := na
    this.wave1Bar := na
    this.wave3Bar := na
    this.wave5Bar := na
    this.wave7Bar := na
    this.cycleLetterIndex := 0
    array.clear(this.retraceHighs)
    array.clear(this.retraceHighBars)
    array.clear(this.retraceLows)
    array.clear(this.retraceLowBars)




// === LABELS ===
var array<int> label_x_array = array.new<int>()
var array<float> label_y_array = array.new<float>()
var array<string> label_text_array = array.new<string>()
var array<string> label_yloc_array = array.new<string>()
var array<color> label_color_array = array.new<color>()
var array<color> label_textcolor_array = array.new<color>()
var array<string> label_size_array = array.new<string>()
var array<string> label_style_array = array.new<string>()
var array<string> label_tooltip_array = array.new<string>()

f_addLabel(int x, float y, string labelText, string yloc, color labelColor, color textcolor, string size, string style, string tooltip) =>
    array.push(label_x_array, x)
    array.push(label_y_array, y)
    array.push(label_text_array, labelText)
    array.push(label_yloc_array, yloc)
    array.push(label_color_array, labelColor)
    array.push(label_textcolor_array, textcolor)
    array.push(label_size_array, size)
    array.push(label_style_array, style)
    array.push(label_tooltip_array, tooltip)


// === CALCULATIONS ===

ema = ta.ema(source = src, length = emaLength)
sma1 = ta.sma(source = src, length = sma1Length)
sma2 = ta.sma(source = src, length = sma2Length)
sma3 = ta.sma(source = src, length = sma3Length)

// SMA 1 Slope (THE TREND INDICATOR)
sma1Past = sma1TrendLookback <= bar_index ? sma1[sma1TrendLookback] : na
sma1Height = sma1 - sma1Past
sma1SlopeAngle = na(sma1Past) or sma1Height == 0 ? 0 : math.atan(sma1Height / sma1TrendLookback) * RADIANS_TO_DEGREES

sma1Trend = math.abs(sma1SlopeAngle) < sma1FlatThreshold ? TREND_FLAT : sma1SlopeAngle > 0 ? TREND_UP : TREND_DOWN
sma1CurrentColor = switch sma1Trend
    TREND_UP => sma1ColorUp
    TREND_DOWN => sma1ColorDown
    => sma1ColorNeutral

// === PLOTS ===
plot(series = emaVisible ? ema : na, title = "EMA", color = emaColor, linewidth = emaWidth, offset = emaOffset)
plot(series = sma1Visible ? sma1 : na, title = "SMA 1", color = sma1CurrentColor, linewidth = sma1Width, offset = sma1Offset)
plot(series = sma2Visible ? sma2 : na, title = "SMA 2", color = sma2Color, linewidth = sma2Width, offset = sma2Offset)
plot(series = sma3Visible ? sma3 : na, title = "SMA 3", color = sma3Color, linewidth = sma3Width, offset = sma3Offset)

// === STOCHASTIC CYCLE DETECTION ===
k = ta.sma(source = ta.stoch(source = close, high = high, low = low, length = periodK), length = smoothK)
d = ta.sma(source = k, length = periodD)

// Cycle zones based on D
inUpZone = d > lowerMidLevel  // Above 45
inDownZone = d < upperMidLevel  // Below 55

// Entering/exiting zones
enteringUpZone = inUpZone and not inUpZone[1]
exitingUpZone = not inUpZone and inUpZone[1] and d < upperMidLevel  // D returned to 55

enteringDownZone = inDownZone and not inDownZone[1]
exitingDownZone = not inDownZone and inDownZone[1] and d > lowerMidLevel  // D returned to 45

// Track cycle highs and lows
var bool inCycleHighZone = false
var bool inCycleLowZone = false
var float cycleHighPrice = na
var float cycleLowPrice = na
var int cycleHighBar = na
var int cycleLowBar = na

// Enter cycle high zone when D > 45
if enteringUpZone
    inCycleHighZone := true
    cycleHighPrice := high
    cycleHighBar := bar_index

// Enter cycle low zone when D < 55
if enteringDownZone
    inCycleLowZone := true
    cycleLowPrice := low
    cycleLowBar := bar_index

// Track highest high in cycle high zone
if inCycleHighZone and (na(cycleHighPrice) or high > cycleHighPrice)
    cycleHighPrice := high
    cycleHighBar := bar_index

// Track lowest low in cycle low zone
if inCycleLowZone and (na(cycleLowPrice) or low < cycleLowPrice)
    cycleLowPrice := low
    cycleLowBar := bar_index

// Confirm cycles when D exits zones
newCycleHigh = inCycleHighZone and exitingUpZone  // D returned to 55 from above 45
newCycleLow = inCycleLowZone and exitingDownZone  // D returned to 45 from below 55

// Exit zones after confirmation
if newCycleHigh
    inCycleHighZone := false

if newCycleLow
    inCycleLowZone := false

// === WAVE COUNTING LOGIC ===
// Trend state detection
trendJustStartedUp = not (sma1SlopeAngle[1] > sma1FlatThreshold) and sma1SlopeAngle > sma1FlatThreshold
trendJustStartedDown = not (sma1SlopeAngle[1] < -sma1FlatThreshold) and sma1SlopeAngle < -sma1FlatThreshold
smaFlat = math.abs(sma1SlopeAngle) < sma1FlatThreshold
smaFlat_prev = math.abs(sma1SlopeAngle[1]) < sma1FlatThreshold

// Wave tracking variables
var WaveCounter waveCounter = WaveCounter.new(0, TREND_NONE, na, na, na, na, na, na, na, na, 0, array.new<float>(), array.new<int>(), array.new<float>(), array.new<int>())

// Reset on trend change or flat
if trendJustStartedUp or trendJustStartedDown or (smaFlat and not smaFlat_prev)
    waveCounter.reset(trendJustStartedUp ? TREND_UP : trendJustStartedDown ? TREND_DOWN : TREND_NONE)

// === DOWNTREND WAVE COUNTING ===
if waveCounter.currentTrend == TREND_DOWN
    // Cycle LOW detected
    if newCycleLow
        cycleLow = cycleLowPrice[1]
        cycleLowBarIndex = cycleLowBar[1]

        // Wave 1: First cycle low after SMA1 commits down
        if waveCounter.waveNumber == 0
            waveCounter.waveNumber := 1
            waveCounter.wave1Value := cycleLow
            waveCounter.wave1Bar := cycleLowBarIndex
            waveCounter.cycleLetterIndex := 0

            if showWaves
                f_addLabel(cycleLowBarIndex, cycleLow, "1", yloc.belowbar, color.new(waveColor, 100), waveColor, waveLabelSizeConst, label.style_label_up, "")
            if showCycles
                f_addLabel(cycleLowBarIndex, cycleLow, "A", yloc.belowbar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_up, "Cycle A")

        // Odd waves (3, 5, 7, 9...) - Check commitment
        else if waveCounter.waveNumber % 2 == 0
            priorWaveValue = waveCounter.waveNumber == 2 ? waveCounter.wave1Value : waveCounter.waveNumber == 4 ? waveCounter.wave3Value : waveCounter.waveNumber == 6 ? waveCounter.wave5Value : waveCounter.wave7Value

            // Check if committed below prior wave
            committed = false
            barsSinceCycle = bar_index - cycleLowBarIndex
            lowestSince = ta.lowest(low, barsSinceCycle + 1)
            if lowestSince < priorWaveValue
                committed := true

            if committed
                // Valid wave
                waveCounter.waveNumber += 1

                if waveCounter.waveNumber == 3
                    waveCounter.wave3Value := cycleLow
                    waveCounter.wave3Bar := cycleLowBarIndex
                else if waveCounter.waveNumber == 5
                    waveCounter.wave5Value := cycleLow
                    waveCounter.wave5Bar := cycleLowBarIndex
                else if waveCounter.waveNumber == 7
                    waveCounter.wave7Value := cycleLow
                    waveCounter.wave7Bar := cycleLowBarIndex

                waveCounter.cycleLetterIndex := 0
                if showWaves
                    f_addLabel(cycleLowBarIndex, cycleLow, str.tostring(waveCounter.waveNumber), yloc.belowbar, color.new(waveColor, 100), waveColor, waveLabelSizeConst, label.style_label_up, "")
                if showCycles
                    f_addLabel(cycleLowBarIndex, cycleLow, "A", yloc.belowbar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_up, "Cycle A")
                array.clear(waveCounter.retraceHighs)
                array.clear(waveCounter.retraceHighBars)
            else
                // Failed wave
                if showWaves
                    f_addLabel(cycleLowBarIndex, cycleLow, "F" + str.tostring(waveCounter.waveNumber + 1), yloc.belowbar, color.new(failedWaveColor, 100), failedWaveColor, waveLabelSizeConst, label.style_label_up, "Failed - did not commit below wave " + str.tostring(waveCounter.waveNumber))
                if showCycles
                    waveCounter.cycleLetterIndex += 1
                    if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                        f_addLabel(cycleLowBarIndex, cycleLow, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex), yloc.belowbar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_up, "")

        // Just a cycle (after failed wave or between waves)
        else if waveCounter.waveNumber % 2 == 1
            array.push(waveCounter.retraceLows, cycleLow)
            array.push(waveCounter.retraceLowBars, cycleLowBarIndex)
            if showCycles and waveCounter.waveNumber > 0
                waveCounter.cycleLetterIndex += 1
                if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                    f_addLabel(cycleLowBarIndex, cycleLow, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex), yloc.belowbar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_up, "")

    // Cycle HIGH detected (even waves - retraces)
    if newCycleHigh and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0
        cycleHigh = cycleHighPrice[1]
        cycleHighBarIndex = cycleHighBar[1]
        array.push(waveCounter.retraceHighs, cycleHigh)
        array.push(waveCounter.retraceHighBars, cycleHighBarIndex)
        if showCycles
            waveCounter.cycleLetterIndex += 1
            if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                f_addLabel(cycleHighBarIndex, cycleHigh, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex), yloc.abovebar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_down, "")

    // When next odd wave confirms, find highest retrace high for even wave
    if newCycleLow and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0 and array.size(waveCounter.retraceHighs) > 0
        highestHigh = array.get(waveCounter.retraceHighs, 0)
        highestBar = array.get(waveCounter.retraceHighBars, 0)
        for i = 1 to array.size(waveCounter.retraceHighs) - 1
            if array.get(waveCounter.retraceHighs, i) > highestHigh
                highestHigh := array.get(waveCounter.retraceHighs, i)
                highestBar := array.get(waveCounter.retraceHighBars, i)
        if showWaves
            f_addLabel(highestBar, highestHigh, str.tostring(waveCounter.waveNumber + 1), yloc.abovebar, color.new(waveColor, 100), waveColor, waveLabelSizeConst, label.style_label_down, "Wave " + str.tostring(waveCounter.waveNumber + 1) + " (highest retrace)")

// === UPTREND WAVE COUNTING ===
if waveCounter.currentTrend == TREND_UP
    // Cycle HIGH detected
    if newCycleHigh
        cycleHigh = cycleHighPrice[1]
        cycleHighBarIndex = cycleHighBar[1]

        // Wave 1: First cycle high after SMA1 commits up
        if waveCounter.waveNumber == 0
            waveCounter.waveNumber := 1
            waveCounter.wave1Value := cycleHigh
            waveCounter.wave1Bar := cycleHighBarIndex
            waveCounter.cycleLetterIndex := 0
            if showWaves
                f_addLabel(cycleHighBarIndex, cycleHigh, "1", yloc.abovebar, color.new(waveColor, 100), waveColor, waveLabelSizeConst, label.style_label_down, "")
            if showCycles
                f_addLabel(cycleHighBarIndex, cycleHigh, "A", yloc.abovebar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_down, "Cycle A")

        // Odd waves (3, 5, 7, 9...) - Check commitment
        else if waveCounter.waveNumber % 2 == 0
            priorWaveValue = waveCounter.waveNumber == 2 ? waveCounter.wave1Value : waveCounter.waveNumber == 4 ? waveCounter.wave3Value : waveCounter.waveNumber == 6 ? waveCounter.wave5Value : waveCounter.wave7Value

            // Check if committed above prior wave
            committed = false
            barsSinceCycle = bar_index - cycleHighBarIndex
            highestSince = ta.highest(high, barsSinceCycle + 1)
            if highestSince > priorWaveValue
                committed := true

            if committed
                // Valid wave
                waveCounter.waveNumber += 1
                if waveCounter.waveNumber == 3
                    waveCounter.wave3Value := cycleHigh
                    waveCounter.wave3Bar := cycleHighBarIndex
                else if waveCounter.waveNumber == 5
                    waveCounter.wave5Value := cycleHigh
                    waveCounter.wave5Bar := cycleHighBarIndex
                else if waveCounter.waveNumber == 7
                    waveCounter.wave7Value := cycleHigh
                    waveCounter.wave7Bar := cycleHighBarIndex
                waveCounter.cycleLetterIndex := 0
                if showWaves
                    f_addLabel(cycleHighBarIndex, cycleHigh, str.tostring(waveCounter.waveNumber), yloc.abovebar, color.new(waveColor, 100), waveColor, waveLabelSizeConst, label.style_label_down, "")
                if showCycles
                    f_addLabel(cycleHighBarIndex, cycleHigh, "A", yloc.abovebar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_down, "Cycle A")
                array.clear(waveCounter.retraceLows)
                array.clear(waveCounter.retraceLowBars)
            else
                // Failed wave
                if showWaves
                    f_addLabel(cycleHighBarIndex, cycleHigh, "F" + str.tostring(waveCounter.waveNumber + 1), yloc.abovebar, color.new(failedWaveColor, 100), failedWaveColor, waveLabelSizeConst, label.style_label_down, "Failed - did not commit above wave " + str.tostring(waveCounter.waveNumber))
                if showCycles
                    waveCounter.cycleLetterIndex += 1
                    if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                        f_addLabel(cycleHighBarIndex, cycleHigh, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex), yloc.abovebar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_down, "")
        // Just a cycle (after failed wave or between waves)
        else if waveCounter.waveNumber % 2 == 1
            array.push(waveCounter.retraceHighs, cycleHigh)
            array.push(waveCounter.retraceHighBars, cycleHighBarIndex)
            if showCycles and waveCounter.waveNumber > 0
                waveCounter.cycleLetterIndex += 1
                if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                    f_addLabel(cycleHighBarIndex, cycleHigh, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex), yloc.abovebar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_down, "")

    // Cycle LOW detected (even waves - retraces)
    if newCycleLow and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0
        cycleLow = cycleLowPrice[1]
        cycleLowBarIndex = cycleLowBar[1]
        array.push(waveCounter.retraceLows, cycleLow)
        array.push(waveCounter.retraceLowBars, cycleLowBarIndex)
        if showCycles
            waveCounter.cycleLetterIndex += 1
            if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                f_addLabel(cycleLowBarIndex, cycleLow, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex), yloc.belowbar, color.new(cycleColor, 100), cycleColor, cycleLabelSizeConst, label.style_label_up, "")

    // When next odd wave confirms, find lowest retrace low for even wave
    if newCycleHigh and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0 and array.size(waveCounter.retraceLows) > 0
        // Find lowest low among retrace cycles
        lowestLow = array.get(waveCounter.retraceLows, 0)
        lowestBar = array.get(waveCounter.retraceLowBars, 0)
        for i = 1 to array.size(waveCounter.retraceLows) - 1
            if array.get(waveCounter.retraceLows, i) < lowestLow
                lowestLow := array.get(waveCounter.retraceLows, i)
                lowestBar := array.get(waveCounter.retraceLowBars, i)
        // This was the even wave
        if showWaves
            f_addLabel(lowestBar, lowestLow, str.tostring(waveCounter.waveNumber + 1), yloc.belowbar, color.new(waveColor, 100), waveColor, waveLabelSizeConst, label.style_label_up, "Wave " + str.tostring(waveCounter.waveNumber + 1) + " (lowest retrace)")

// === DRAW LABELS ===
if barstate.islast
    for i = 0 to array.size(label_x_array) - 1
        label.new(
             x = array.get(label_x_array, i),
             y = array.get(label_y_array, i),
             text = array.get(label_text_array, i),
             xloc = xloc.bar_index,
             yloc = array.get(label_yloc_array, i),
             color = array.get(label_color_array, i),
             style = array.get(label_style_array, i),
             textcolor = array.get(label_textcolor_array, i),
             size = array.get(label_size_array, i),
             textalign = text.align_center,
             tooltip = array.get(label_tooltip_array, i)
        )

