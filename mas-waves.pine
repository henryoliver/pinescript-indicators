// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © henry_oliver
// Top Dog Trading Wave Counting - Based on Barry Burns methodology

//@version=6
indicator(title = "MAs & Waves", shorttitle = "MA&W", overlay = true, max_labels_count = 500)

// === CONSTANTS ===
// Nord Theme Color
const color NORD0  = #2E3440
const color NORD1  = #3B4252
const color NORD2  = #434C5E
const color NORD3  = #4C566A
const color NORD4  = #D8DEE9
const color NORD5  = #E5E9F0
const color NORD6  = #ECEFF4
const color NORD7  = #8FBCBB
const color NORD8  = #88C0D0
const color NORD9  = #81A1C1
const color NORD10 = #5E81AC
const color NORD11 = #BF616A
const color NORD12 = #D08770
const color NORD13 = #EBCB8B
const color NORD14 = #A3BE8C
const color NORD15 = #B48EAD

// Calculation Constants
const string TREND_UP     = "up"
const string TREND_DOWN   = "down"
const string TREND_FLAT   = "flat"
const string TREND_NONE   = "none"

const float RADIANS_TO_DEGREES = 180 / math.pi

// Cycle letters
const array<string> CYCLE_LETTERS = array.from("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z")

// === INPUTS ===
src = input.source(defval = close, title = "Source")

// EMA
emaVisible = input.bool(defval = true, title = "Visible", group = "EMA")
emaLength = input.int(defval = 15, title = "Length", minval = 1, group = "EMA")
emaOffset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "EMA")
emaColor = input.color(defval = NORD3, title = "Color", group = "EMA")
emaWidth = input.int(defval = 2, title = "Line Width", minval = 1, maxval = 10, group = "EMA")

// SMA 1 (50 SMA - THE TREND INDICATOR)
sma1Visible = input.bool(defval = true, title = "Visible", group = "SMA 1")
sma1Length = input.int(defval = 50, title = "Length", minval = 1, group = "SMA 1")
sma1Offset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "SMA 1")
sma1TrendLookback = input.int(defval = 5, title = "Trend Lookback (Bars)", minval = 1, maxval = 20,
     tooltip = "Number of bars to look back to determine slope angle", group = "SMA 1")
sma1FlatThreshold = input.float(defval = 0.0001, title = "Flat Threshold (Degrees)", minval = 0.0001, maxval = 5.0, step = 0.0001,
     tooltip = "Angle threshold in degrees - slopes between -threshold and +threshold are considered flat", group = "SMA 1")
sma1ColorUp = input.color(defval = color.new(color = NORD8, transp = 60), title = "Color (Up)", group = "SMA 1")
sma1ColorNeutral = input.color(defval = NORD2, title = "Color (Neutral)", group = "SMA 1")
sma1ColorDown = input.color(defval = color.new(color = NORD11, transp = 60), title = "Color (Down)", group = "SMA 1")
sma1Width = input.int(defval = 3, title = "Line Width", minval = 1, maxval = 10, group = "SMA 1")

// SMA 2 & 3
sma2Visible = input.bool(defval = true, title = "Visible", group = "SMA 2")
sma2Length = input.int(defval = 100, title = "Length", minval = 1, group = "SMA 2")
sma2Offset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "SMA 2")
sma2Color = input.color(defval = NORD1, title = "Color", group = "SMA 2")
sma2Width = input.int(defval = 4, title = "Line Width", minval = 1, maxval = 10, group = "SMA 2")

sma3Visible = input.bool(defval = true, title = "Visible", group = "SMA 3")
sma3Length = input.int(defval = 200, title = "Length", minval = 1, group = "SMA 3")
sma3Offset = input.int(defval = 0, title = "Offset", minval = -500, maxval = 500, group = "SMA 3")
sma3Color = input.color(defval = NORD1, title = "Color", group = "SMA 3")
sma3Width = input.int(defval = 5, title = "Line Width", minval = 1, maxval = 10, group = "SMA 3")

// Wave Counting
showWaves = input.bool(defval = true, title = "Show Wave Numbers", group = "Wave Counting")
showCycles = input.bool(defval = true, title = "Show Cycle Letters", group = "Wave Counting")
periodK = input.int(defval = 5, title = "%K Length", minval = 1, group = "Wave Counting")
smoothK = input.int(defval = 2, title = "%K Smoothing", minval = 1, group = "Wave Counting")
periodD = input.int(defval = 3, title = "%D Smoothing", minval = 1, group = "Wave Counting")
upperMidLevel = input.int(defval = 55, title = "Upper Mid Level", minval = 50, maxval = 100,
     tooltip = "D must return to this level to confirm cycle high", group = "Wave Counting")
lowerMidLevel = input.int(defval = 45, title = "Lower Mid Level", minval = 0, maxval = 50,
     tooltip = "D must return to this level to confirm cycle low", group = "Wave Counting")
waveColor = input.color(defval = NORD3, title = "Wave Label Color", group = "Wave Counting")
waveLabelSize = input.string(defval = "normal", title = "Wave Label Size",
     options = ["auto", "tiny", "small", "normal", "large", "huge"], group = "Wave Counting")
cycleColor = input.color(defval = NORD2, title = "Cycle Label Color", group = "Wave Counting")
cycleLabelSize = input.string(defval = "small", title = "Cycle Label Size",
     options = ["auto", "tiny", "small", "normal", "large", "huge"], group = "Wave Counting")
failedWaveColor = input.color(defval = NORD11, title = "Failed Wave Color", group = "Wave Counting")

// Map wave label size string to size constant
waveLabelSizeConst = switch waveLabelSize
    "auto"   => size.auto
    "tiny"   => size.tiny
    "small"  => size.small
    "normal" => size.normal
    "large"  => size.large
    "huge"   => size.huge
    => size.normal  // fallback

// Map cycle label size string to size constant
cycleLabelSizeConst = switch cycleLabelSize
    "auto"   => size.auto
    "tiny"   => size.tiny
    "small"  => size.small
    "normal" => size.normal
    "large"  => size.large
    "huge"   => size.huge
    => size.small  // fallback

// === TYPES ===
type Wave
    int number
    string trend
    float value
    int bar

type WaveCounter
    int waveNumber
    string currentTrend
    array<float> impulseWaveValues
    array<int> impulseWaveBars
    int cycleLetterIndex
    array<float> retraceHighs
    array<int> retraceHighBars
    array<float> retraceLows
    array<int> retraceLowBars

method reset(WaveCounter this, string newTrend) =>
    this.waveNumber := 0
    this.currentTrend := newTrend
    this.cycleLetterIndex := 0
    array.clear(this.impulseWaveValues)
    array.clear(this.impulseWaveBars)
    array.clear(this.retraceHighs)
    array.clear(this.retraceHighBars)
    array.clear(this.retraceLows)
    array.clear(this.retraceLowBars)




// === CALCULATIONS ===

ema = ta.ema(source = src, length = emaLength)
sma1 = ta.sma(source = src, length = sma1Length)
sma2 = ta.sma(source = src, length = sma2Length)
sma3 = ta.sma(source = src, length = sma3Length)

// SMA 1 Slope (THE TREND INDICATOR)
sma1Past = sma1TrendLookback <= bar_index ? sma1[sma1TrendLookback] : na
sma1Height = sma1 - sma1Past
sma1SlopeAngle = na(sma1Past) or sma1Height == 0 ? 0 : math.atan(sma1Height / sma1TrendLookback) * RADIANS_TO_DEGREES

sma1Trend = math.abs(sma1SlopeAngle) < sma1FlatThreshold ? TREND_FLAT : sma1SlopeAngle > 0 ? TREND_UP : TREND_DOWN
sma1CurrentColor = switch sma1Trend
    TREND_UP => sma1ColorUp
    TREND_DOWN => sma1ColorDown
    => sma1ColorNeutral

// === PLOTS ===
plot(series = emaVisible ? ema : na, title = "EMA", color = emaColor, linewidth = emaWidth, offset = emaOffset)
plot(series = sma1Visible ? sma1 : na, title = "SMA 1", color = sma1CurrentColor, linewidth = sma1Width, offset = sma1Offset)
plot(series = sma2Visible ? sma2 : na, title = "SMA 2", color = sma2Color, linewidth = sma2Width, offset = sma2Offset)
plot(series = sma3Visible ? sma3 : na, title = "SMA 3", color = sma3Color, linewidth = sma3Width, offset = sma3Offset)

// === STOCHASTIC CYCLE DETECTION ===
stochK_smoothed = ta.sma(source = ta.stoch(source = close, high = high, low = low, length = periodK), length = smoothK)
stochD_main = ta.sma(source = stochK_smoothed, length = periodD)

// Cycle zones based on D
inUpZone = stochD_main > lowerMidLevel  // Above 45
inDownZone = stochD_main < upperMidLevel  // Below 55

// Entering/exiting zones
enteringUpZone = inUpZone and not inUpZone[1]
exitingUpZone = not inUpZone and inUpZone[1] and stochD_main < upperMidLevel  // D returned to 55

enteringDownZone = inDownZone and not inDownZone[1]
exitingDownZone = not inDownZone and inDownZone[1] and stochD_main > lowerMidLevel  // D returned to 45

// Track cycle highs and lows
var bool inCycleHighZone = false
var bool inCycleLowZone = false
var float cycleHighPrice = na
var float cycleLowPrice = na
var int cycleHighBar = na
var int cycleLowBar = na

// Enter cycle high zone when D > 45
if enteringUpZone
    inCycleHighZone := true
    cycleHighPrice := high
    cycleHighBar := bar_index

// Enter cycle low zone when D < 55
if enteringDownZone
    inCycleLowZone := true
    cycleLowPrice := low
    cycleLowBar := bar_index

// Track highest high in cycle high zone
if inCycleHighZone and (na(cycleHighPrice) or high > cycleHighPrice)
    cycleHighPrice := high
    cycleHighBar := bar_index

// Track lowest low in cycle low zone
if inCycleLowZone and (na(cycleLowPrice) or low < cycleLowPrice)
    cycleLowPrice := low
    cycleLowBar := bar_index

// Confirm cycles when D exits zones
newCycleHigh = inCycleHighZone and exitingUpZone  // D returned to 55 from above 45
newCycleLow = inCycleLowZone and exitingDownZone  // D returned to 45 from below 55

// Exit zones after confirmation
if newCycleHigh
    inCycleHighZone := false

if newCycleLow
    inCycleLowZone := false

// === WAVE COUNTING LOGIC ===
// Trend state detection
trendJustStartedUp = not (sma1SlopeAngle[1] > sma1FlatThreshold) and sma1SlopeAngle > sma1FlatThreshold
trendJustStartedDown = not (sma1SlopeAngle[1] < -sma1FlatThreshold) and sma1SlopeAngle < -sma1FlatThreshold
smaFlat = math.abs(sma1SlopeAngle) < sma1FlatThreshold
smaFlat_prev = math.abs(sma1SlopeAngle[1]) < sma1FlatThreshold

// Wave tracking variables
var WaveCounter waveCounter = WaveCounter.new(0, TREND_NONE, array.new<float>(), array.new<int>(), 0, array.new<float>(), array.new<int>(), array.new<float>(), array.new<int>())

// Reset on trend change or flat
if trendJustStartedUp or trendJustStartedDown or (smaFlat and not smaFlat_prev)
    waveCounter.reset(trendJustStartedUp ? TREND_UP : trendJustStartedDown ? TREND_DOWN : TREND_NONE)

// === DOWNTREND WAVE COUNTING ===
if waveCounter.currentTrend == TREND_DOWN
    // Cycle LOW detected
    if newCycleLow
        cycleLow = cycleLowPrice[1]
        cycleLowBarIndex = cycleLowBar[1]

        // Wave 1: First cycle low after SMA1 commits down
        if waveCounter.waveNumber == 0
            waveCounter.waveNumber := 1
            array.push(waveCounter.impulseWaveValues, cycleLow)
            array.push(waveCounter.impulseWaveBars, cycleLowBarIndex)
            waveCounter.cycleLetterIndex := 0

            if showWaves
                label.new(cycleLowBarIndex, na, "1",
                     style = label.style_label_up, color = color.new(waveColor, 100),
                     textcolor = waveColor, size = waveLabelSizeConst, yloc = yloc.belowbar,
                     textalign = text.align_center)

            if showCycles
                label.new(cycleLowBarIndex, na, "A",
                     style = label.style_label_up, color = color.new(cycleColor, 100),
                     textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.belowbar,
                     textalign = text.align_center, tooltip = "Cycle A")

        // Odd waves (3, 5, 7, 9...) - Check commitment
        else if waveCounter.waveNumber % 2 == 0
            priorWaveValue = array.last(waveCounter.impulseWaveValues)

            // Check if committed below prior wave
            committed = false
            for i = 0 to bar_index - cycleLowBarIndex
                barIdx = cycleLowBarIndex + i
                if barIdx <= bar_index
                    o = open[bar_index - barIdx]
                    c = close[bar_index - barIdx]
                    l = low[bar_index - barIdx]

                    // Close must be below prior wave AND real body must be at or below prior wave
                    if c < priorWaveValue and o <= priorWaveValue
                        committed := true
                        break

            if committed
                // Valid wave
                waveCounter.waveNumber += 1
                array.push(waveCounter.impulseWaveValues, cycleLow)
                array.push(waveCounter.impulseWaveBars, cycleLowBarIndex)
                waveCounter.cycleLetterIndex := 0

                if showWaves
                    label.new(cycleLowBarIndex, na, str.tostring(waveCounter.waveNumber),
                         style = label.style_label_up, color = color.new(waveColor, 100),
                         textcolor = waveColor, size = waveLabelSizeConst, yloc = yloc.belowbar,
                         textalign = text.align_center)

                if showCycles
                    label.new(cycleLowBarIndex, na, "A",
                         style = label.style_label_up, color = color.new(cycleColor, 100),
                         textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.belowbar,
                         textalign = text.align_center, tooltip = "Cycle A")

                // Clear retrace tracking for next even wave
                array.clear(waveCounter.retraceHighs)
                array.clear(waveCounter.retraceHighBars)
            else
                // Failed wave
                if showWaves
                    label.new(cycleLowBarIndex, na, "F" + str.tostring(waveCounter.waveNumber + 1),
                         style = label.style_label_up, color = color.new(failedWaveColor, 100),
                         textcolor = failedWaveColor, size = waveLabelSizeConst, yloc = yloc.belowbar,
                         textalign = text.align_center, tooltip = "Failed - did not commit below wave " + str.tostring(waveCounter.waveNumber))

                if showCycles
                    waveCounter.cycleLetterIndex += 1
                    if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                        label.new(cycleLowBarIndex, na, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex),
                             style = label.style_label_up, color = color.new(cycleColor, 100),
                             textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.belowbar,
                             textalign = text.align_center)

        // Just a cycle (after failed wave or between waves)
        else if waveCounter.waveNumber % 2 == 1
            // Store for even wave calculation
            array.push(waveCounter.retraceLows, cycleLow)
            array.push(waveCounter.retraceLowBars, cycleLowBarIndex)

            if showCycles and waveCounter.waveNumber > 0
                waveCounter.cycleLetterIndex += 1
                if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                    label.new(cycleLowBarIndex, na, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex),
                         style = label.style_label_up, color = color.new(cycleColor, 100),
                         textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.belowbar,
                         textalign = text.align_center)

    // Cycle HIGH detected (even waves - retraces)
    if newCycleHigh and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0
        cycleHigh = cycleHighPrice[1]
        cycleHighBarIndex = cycleHighBar[1]

        // Store this retrace high
        array.push(waveCounter.retraceHighs, cycleHigh)
        array.push(waveCounter.retraceHighBars, cycleHighBarIndex)

        if showCycles
            waveCounter.cycleLetterIndex += 1
            if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                label.new(cycleHighBarIndex, na, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex),
                     style = label.style_label_down, color = color.new(cycleColor, 100),
                     textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.abovebar,
                     textalign = text.align_center)

    // When next odd wave confirms, find highest retrace high for even wave
    if newCycleLow and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0 and array.size(waveCounter.retraceHighs) > 0
        // Find highest high among retrace cycles
        highestHigh = array.get(waveCounter.retraceHighs, 0)
        highestBar = array.get(waveCounter.retraceHighBars, 0)

        for i = 1 to array.size(waveCounter.retraceHighs) - 1
            if array.get(waveCounter.retraceHighs, i) > highestHigh
                highestHigh := array.get(waveCounter.retraceHighs, i)
                highestBar := array.get(waveCounter.retraceHighBars, i)

        // This was the even wave
        if showWaves
            label.new(highestBar, na, str.tostring(waveCounter.waveNumber + 1),
                 style = label.style_label_down, color = color.new(waveColor, 100),
                 textcolor = waveColor, size = waveLabelSizeConst, yloc = yloc.abovebar,
                 textalign = text.align_center, tooltip = "Wave " + str.tostring(waveCounter.waveNumber + 1) + " (highest retrace)")

// === UPTREND WAVE COUNTING ===
if waveCounter.currentTrend == TREND_UP
    // Cycle HIGH detected
    if newCycleHigh
        cycleHigh = cycleHighPrice[1]
        cycleHighBarIndex = cycleHighBar[1]

        // Wave 1: First cycle high after SMA1 commits up
        if waveCounter.waveNumber == 0
            waveCounter.waveNumber := 1
            array.push(waveCounter.impulseWaveValues, cycleHigh)
            array.push(waveCounter.impulseWaveBars, cycleHighBarIndex)
            waveCounter.cycleLetterIndex := 0

            if showWaves
                label.new(cycleHighBarIndex, na, "1",
                     style = label.style_label_down, color = color.new(waveColor, 100),
                     textcolor = waveColor, size = waveLabelSizeConst, yloc = yloc.abovebar,
                     textalign = text.align_center)

            if showCycles
                label.new(cycleHighBarIndex, na, "A",
                     style = label.style_label_down, color = color.new(cycleColor, 100),
                     textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.abovebar,
                     textalign = text.align_center, tooltip = "Cycle A")

        // Odd waves (3, 5, 7, 9...) - Check commitment
        else if waveCounter.waveNumber % 2 == 0
            priorWaveValue = array.last(waveCounter.impulseWaveValues)

            // Check if committed above prior wave
            committed = false
            for i = 0 to bar_index - cycleHighBarIndex
                barIdx = cycleHighBarIndex + i
                if barIdx <= bar_index
                    o = open[bar_index - barIdx]
                    c = close[bar_index - barIdx]
                    h = high[bar_index - barIdx]

                    // Close must be above prior wave AND real body must be at or above prior wave
                    if c > priorWaveValue and o >= priorWaveValue
                        committed := true
                        break

            if committed
                // Valid wave
                waveCounter.waveNumber += 1
                array.push(waveCounter.impulseWaveValues, cycleHigh)
                array.push(waveCounter.impulseWaveBars, cycleHighBarIndex)
                waveCounter.cycleLetterIndex := 0

                if showWaves
                    label.new(cycleHighBarIndex, na, str.tostring(waveCounter.waveNumber),
                         style = label.style_label_down, color = color.new(waveColor, 100),
                         textcolor = waveColor, size = waveLabelSizeConst, yloc = yloc.abovebar,
                         textalign = text.align_center)

                if showCycles
                    label.new(cycleHighBarIndex, na, "A",
                         style = label.style_label_down, color = color.new(cycleColor, 100),
                         textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.abovebar,
                         textalign = text.align_center, tooltip = "Cycle A")

                // Clear retrace tracking for next even wave
                array.clear(waveCounter.retraceLows)
                array.clear(waveCounter.retraceLowBars)
            else
                // Failed wave
                if showWaves
                    label.new(cycleHighBarIndex, na, "F" + str.tostring(waveCounter.waveNumber + 1),
                         style = label.style_label_down, color = color.new(failedWaveColor, 100),
                         textcolor = failedWaveColor, size = waveLabelSizeConst, yloc = yloc.abovebar,
                         textalign = text.align_center, tooltip = "Failed - did not commit above wave " + str.tostring(waveCounter.waveNumber))

                if showCycles
                    waveCounter.cycleLetterIndex += 1
                    if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                        label.new(cycleHighBarIndex, na, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex),
                             style = label.style_label_down, color = color.new(cycleColor, 100),
                             textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.abovebar,
                             textalign = text.align_center)

        // Just a cycle (after failed wave or between waves)
        else if waveCounter.waveNumber % 2 == 1
            // Store for even wave calculation
            array.push(waveCounter.retraceHighs, cycleHigh)
            array.push(waveCounter.retraceHighBars, cycleHighBarIndex)

            if showCycles and waveCounter.waveNumber > 0
                waveCounter.cycleLetterIndex += 1
                if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                    label.new(cycleHighBarIndex, na, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex),
                         style = label.style_label_down, color = color.new(cycleColor, 100),
                         textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.abovebar,
                         textalign = text.align_center)

    // Cycle LOW detected (even waves - retraces)
    if newCycleLow and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0
        cycleLow = cycleLowPrice[1]
        cycleLowBarIndex = cycleLowBar[1]

        // Store this retrace low
        array.push(waveCounter.retraceLows, cycleLow)
        array.push(waveCounter.retraceLowBars, cycleLowBarIndex)

        if showCycles
            waveCounter.cycleLetterIndex += 1
            if waveCounter.cycleLetterIndex < array.size(CYCLE_LETTERS)
                label.new(cycleLowBarIndex, na, array.get(CYCLE_LETTERS, waveCounter.cycleLetterIndex),
                     style = label.style_label_up, color = color.new(cycleColor, 100),
                     textcolor = cycleColor, size = cycleLabelSizeConst, yloc = yloc.belowbar,
                     textalign = text.align_center)

    // When next odd wave confirms, find lowest retrace low for even wave
    if newCycleHigh and waveCounter.waveNumber % 2 == 1 and waveCounter.waveNumber > 0 and array.size(waveCounter.retraceLows) > 0
        // Find lowest low among retrace cycles
        lowestLow = array.get(waveCounter.retraceLows, 0)
        lowestBar = array.get(waveCounter.retraceLowBars, 0)

        for i = 1 to array.size(waveCounter.retraceLows) - 1
            if array.get(waveCounter.retraceLows, i) < lowestLow
                lowestLow := array.get(waveCounter.retraceLows, i)
                lowestBar := array.get(waveCounter.retraceLowBars, i)

        // This was the even wave
        if showWaves
            label.new(lowestBar, na, str.tostring(waveCounter.waveNumber + 1),
                 style = label.style_label_up, color = color.new(waveColor, 100),
                 textcolor = waveColor, size = waveLabelSizeConst, yloc = yloc.belowbar,
                 textalign = text.align_center, tooltip = "Wave " + str.tostring(waveCounter.waveNumber + 1) + " (lowest retrace)")
